cvm bytecode notes

how it works:
- take the ast and convert to bytecode instructions
- each function gets virtual registers (r0, r1, r2, etc)
- during codegen track which registers are in use and reuse them when variables die
- instructions are fixed 32-bit like lua

instruction format:
- 32 bits total

- iABC format: [6-bit opcode][8-bit A][9-bit B][9-bit C]
  - for three operand instructions

- iABx format: [6-bit opcode][8-bit A][18-bit Bx]
  - for instructions with one register and a large immediate/index

- max 256 registers per function (8 bits)

instructions:

iABC
- ADD rA, rB, rC
- SUB rA, rB, rC
- MUL rA, rB, rC
- DIV rA, rB, rC
- MOD rA, rB, rC
- MOV rA, rB, -

iABx
- LOADK rA, Kx -> load constant from constant table at index Kx into rA

constant table:
- each function has a constant table (vec of values)
- stores int literals, float literals, strings, etc
- LOADK references by index
- built during codegen

example codegen:
- for expression like 5 + y
- emit LOADK r0, K0 (where constants[0] = 5)
- load y from symbol table (say it's in r1)
- emit ADD r2, r0, r1
- result in r2