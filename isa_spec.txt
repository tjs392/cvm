cvm bytecode notes

My bytecode design was heavily inspired by Lua's bytecode system:
https://the-ravi-programming-language.readthedocs.io/en/latest/lua_bytecode_reference.html

how it works:
- take the ast and convert to bytecode instructions
- each function gets virtual registers (r0, r1, r2, etc)
- during codegen track which registers are in use and reuse them when variables die
- instructions are fixed 32-bit like lua

instruction format:
- 32 bits total

- iABC format: [6-bit opcode][8-bit A][9-bit B][9-bit C]
  - for three operand instructions (arithmetic, comparisons, moves)

- iABx format: [6-bit opcode][8-bit A][18-bit Bx]
  - for instructions with one register and a large immediate/index

- iAsBx format: [6-bit opcode][8-bit unused][18-bit sBx (signed)]
  - for jump instructions with signed offset

- max 256 registers per function (8 bits)

instructions:

iABC (arithmetic and move)
- ADD rA, rB, rC
- SUB rA, rB, rC
- MUL rA, rB, rC
- DIV rA, rB, rC
- MOD rA, rB, rC
- MOV rA, rB

iABC (comparisons - store result as 0 or 1)
- EQ rA, rB, rC --> rA = (rB == rC) ? 1 : 0
- NE rA, rB, rC --> rA = (rB != rC) ? 1 : 0
- LT rA, rB, rC --> rA = (rB < rC) ? 1 : 0
- LE rA, rB, rC --> rA = (rB <= rC) ? 1 : 0
- GT rA, rB, rC --> rA = (rB > rC) ? 1 : 0
- GE rA, rB, rC --> rA = (rB >= rC) ? 1 : 0

iABx
- LOADK rA, Kx -> load constant from constant table at index Kx into rA
- TEST rA -> check if rA is true (nonzero)

iAsBx (control flow)
- JMP sBx -> unconditional jump by signed offset sBx instructions
  - VM semantics: PC is incremented before jump, so JMP 0 = continue, JMP -1 = repeat current

control flow patterns:

  if statement:
  - for "if (x < 5) { body }"
    1. LT r1, r0, K0
    2. TEST r1
    3. JMP +N
    4. [body instructions]
    5. [continue...]

  if-else statement:
  - for "if (x < 5) { then_body } else { else_body }"
    1. LT r1, r0, K0
    2. TEST r1
    3. JMP +N
    4. [then_body instructions]
    5. JMP +M
    6. [else_body instructions]
    7. [continue...]

  while loop:
  - for "while (x < 5) { body }"
    [loop_start:]
    1. LT r1, r0, K0
    2. TEST r1
    3. JMP +N
    4. [body instructions]
    5. JMP -M
    [loop_end:]


constant table:
- each function has a constant table (vec of values)
- stores int literals, float literals, strings, etc
- LOADK references by index
- built during codegen with deduplication (same value = same index)

register allocation:
- permanent registers: assigned to declared variables, never freed
- temporary registers: used for intermediate computations, freed after use
- bitvec tracks register state (0 = free, 1 = in use)
- allocator finds first free register (first_zero)
- target register optimization: expressions can write directly to destination